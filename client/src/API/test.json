[
  {
    "trigger_name": "trigger_delivery_completion_after",
    "timing": "AFTER",
    "event": "UPDATE",
    "trigger_definition": "CREATE TRIGGER trigger_delivery_completion_after AFTER UPDATE ON public.user_subscriptions FOR EACH ROW WHEN ((old.next_delivery_status IS DISTINCT FROM new.next_delivery_status)) EXECUTE FUNCTION handle_delivery_completion()",
    "function_schema": "public",
    "function_name": "handle_delivery_completion",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_delivery_completion()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_next_delivery_date timestamp with time zone;\r\n    v_meal_delivery_info record;\r\nBEGIN\r\n    -- Check if delivery status changed to 'delivered'\r\n    IF TG_OP = 'UPDATE' AND \r\n       OLD.next_delivery_status != 'delivered' AND \r\n       NEW.next_delivery_status = 'delivered' THEN\r\n        \r\n        -- Add to delivery history\r\n        PERFORM add_delivery_to_history(\r\n            NEW.id,\r\n            OLD.next_delivery_date,\r\n            OLD.next_delivery_meals,\r\n            'delivered'\r\n        );\r\n        \r\n        -- Increment consumed meals\r\n        UPDATE user_subscriptions \r\n        SET consumed_meals = LEAST(consumed_meals + OLD.next_delivery_meals, total_meals)\r\n        WHERE id = NEW.id;\r\n        \r\n        RAISE NOTICE 'Delivery completed for subscription %, consumed meals updated', NEW.id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "trigger_name": "trigger_subscription_lifecycle_before",
    "timing": "BEFORE",
    "event": "INSERT",
    "trigger_definition": "CREATE TRIGGER trigger_subscription_lifecycle_before BEFORE INSERT OR UPDATE ON public.user_subscriptions FOR EACH ROW EXECUTE FUNCTION handle_subscription_lifecycle()",
    "function_schema": "public",
    "function_name": "handle_subscription_lifecycle",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_subscription_lifecycle()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_next_delivery_date      timestamp with time zone;\n    v_meal_delivery_info      RECORD;  -- will contain next_meal (jsonb) and meals_count (int)\n    v_status_changed          boolean := false;\n    v_preferred_time_changed  boolean := false;\n    v_delivery_days_changed   boolean := false;\nBEGIN\n    ------------------------------------------------------------------\n    -- 1️⃣ Detect what changed (INSERT vs UPDATE)\n    ------------------------------------------------------------------\n    IF TG_OP = 'UPDATE' THEN\n        v_status_changed          := (OLD.status <> NEW.status);\n        v_preferred_time_changed  := (OLD.preferred_delivery_time <> NEW.preferred_delivery_time);\n        v_delivery_days_changed   := (OLD.delivery_days IS DISTINCT FROM NEW.delivery_days);\n    ELSE\n        -- INSERT – treat as a status change so the rest of the logic runs\n        v_status_changed := true;\n    END IF;\n\n    ------------------------------------------------------------------\n    -- 2️⃣ Preferred‑delivery‑time change – delegate to helper function\n    ------------------------------------------------------------------\n    IF TG_OP = 'UPDATE' AND v_preferred_time_changed THEN\n        PERFORM update_delivery_times_for_preferred_time(NEW.id, NEW.preferred_delivery_time);\n        -- The helper may issue another UPDATE; the trigger will fire again but\n        -- the guard logic above prevents an endless loop.\n    END IF;\n\n    ------------------------------------------------------------------\n    -- 3️⃣ Main active‑subscription processing\n    ------------------------------------------------------------------\n    IF NEW.status = 'active'\n       AND NEW.delivery_days IS NOT NULL\n       AND array_length(NEW.delivery_days, 1) > 0\n       AND NEW.consumed_meals < NEW.total_meals\n       AND NOT NEW.is_paused THEN\n\n        -- 3a️⃣ Compute the next delivery date (respecting preferred time)\n        v_next_delivery_date := get_next_delivery_date_with_time(\n                                    NEW.delivery_days,\n                                    NEW.preferred_delivery_time\n                                );\n\n        -- 3b️⃣ Retrieve the *single* next‑meal JSONB and count via the SRF.\n        SELECT next_meal, meals_count\n        INTO v_meal_delivery_info\n        FROM calculate_next_meal_delivery(NEW)\n        LIMIT 1;  -- the SRF returns at most one row\n\n        IF NOT FOUND\n           OR v_meal_delivery_info.meals_count IS NULL\n           OR v_meal_delivery_info.meals_count = 0 THEN\n            -- No meals can be scheduled – clear delivery columns\n            NEW.next_delivery_date   := NULL;\n            NEW.next_delivery_meal   := NULL;   -- jsonb column\n            NEW.next_delivery_meals  := NULL;\n            NEW.next_delivery_status := NULL;\n        ELSE\n            -- A valid delivery can be scheduled\n            NEW.next_delivery_date   := v_next_delivery_date;\n            NEW.next_delivery_meal   := v_meal_delivery_info.next_meal;\n            NEW.next_delivery_meals  := v_meal_delivery_info.meals_count;\n            NEW.next_delivery_status := 'scheduled';\n            RAISE NOTICE\n                'Scheduled next delivery for subscription % on % with % meals',\n                NEW.id, v_next_delivery_date, v_meal_delivery_info.meals_count;\n        END IF;\n\n    ELSE\n        -- Inactive / paused / completed – clear fields\n        NEW.next_delivery_date   := NULL;\n        NEW.next_delivery_meal   := NULL;\n        NEW.next_delivery_meals  := NULL;\n        NEW.next_delivery_status := NULL;\n    END IF;\n\n    ------------------------------------------------------------------\n    -- 4️⃣ Completion handling – when all meals are consumed\n    ------------------------------------------------------------------\n    IF NEW.consumed_meals >= NEW.total_meals THEN\n        NEW.end_date := CURRENT_DATE;\n        NEW.next_delivery_date   := NULL;\n        NEW.next_delivery_meal   := NULL;\n        NEW.next_delivery_meals  := NULL;\n        NEW.next_delivery_status := NULL;\n        RAISE NOTICE 'Subscription % completed – all meals consumed', NEW.id;\n    END IF;\n\n    ------------------------------------------------------------------\n    -- 5️⃣ Touch the audit column\n    ------------------------------------------------------------------\n    NEW.updated_at := NOW();\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "trigger_name": "trigger_update_timestamp_user_subscriptions",
    "timing": "BEFORE",
    "event": "UPDATE",
    "trigger_definition": "CREATE TRIGGER trigger_update_timestamp_user_subscriptions BEFORE UPDATE ON public.user_subscriptions FOR EACH ROW EXECUTE FUNCTION update_timestamp()",
    "function_schema": "public",
    "function_name": "update_timestamp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
  }
]